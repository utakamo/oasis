#!/usr/bin/env lua

local jsonc  = require("luci.jsonc")

local methods = {
    function_calling = {
        args = { tool = "a_string", param = "a_string" },

        call = function(args)
            local uci = require("luci.model.uci").cursor()
            local client = require("oasis.local.tool.client")
            local common = require("oasis.common")

            -- Parse param string ("name:type:value" separated by comma/semicolon) or JSON into a Lua table.
            local function parse_param_str(p)
                if not p or #p == 0 then return {} end

                local as_json = jsonc.parse(p)
                if type(as_json) == "table" then
                    return as_json
                end

                local args = {}
                for entry in tostring(p):gmatch("[^,;]+") do
                    local name, typ, val = entry:match("^([^:]+):([^:]+):(.+)$")
                    if name then
                        if typ == "number" or typ == "integer" then
                            args[name] = tonumber(val)
                        elseif typ == "boolean" then
                            args[name] = (val == "true" or val == "1")
                        else
                            args[name] = val
                        end
                    end
                end
                return args
            end

            local info = uci:get_all("oasis") or {}

            -- Search for the tool definition
            local target_def
            for sect, _ in pairs(info) do
                local target = info[sect]
                if target and tostring(target[".type"]) == "tool" and target.name == args.tool then
                    target_def = target
                    break
                end
            end

            local r = {}

            if not target_def then
                r.result = jsonc.stringify({error = "Not Found"})
                return r
            end

            if tostring(target_def.enable) ~= "1" then
                r.result = jsonc.stringify({error = "Execution of the specified tool is prohibited."})
                return r
            end

            local param_tbl = parse_param_str(args.param)
            local res = client.exec_server_tool(common.ai.format.rpc_output, args.tool, param_tbl)
            r.result = jsonc.stringify(res or { error = "No response" })
            return r
        end
    },

    tool_list = {
        call = function()
            local uci = require("luci.model.uci").cursor()

            local tools = uci:get_all(common.db.uci.cfg)

            -- Delete unnecessary information
            tools.debug     = nil
            tools.rpc       = nil
            tools.storage   = nil
            tools.role      = nil
            tools.support   = nil
            tools.assist    = nil
            tools.rollback  = nil
            tools.console   = nil

            for key, tbl in pairs(tools) do
                if (tbl[".type"] == "service") or ( tbl[".type"] == "chat") then
                    tools[key] = nil
                end
            end

            local server_list = {}
            local seen = {}

            for _, tool in pairs(tools) do
                if not seen[tool.server] then
                    server_list[#server_list + 1] = tool.server
                    seen[tool.server] = true
                end
            end

            local server_info = {}
            for _, name in pairs(server_list) do
                    server_info[#server_info + 1] = {}
                    server_info[#server_info].name = name
                if common.check_server_loaded(name) then
                    server_info[#server_info].status = "loaded"
                else
                    server_info[#server_info].status = "loding"
                end
            end

            local info = {}
            info.tools = tools
            info.server_info = server_info
            info.local_tool = uci:get_bool(common.db.uci.cfg, common.db.uci.sect.support, "local_tool")

            r.result = jsonc.stringify({ local_tool = local_tool })
            return r
        end
    },
}

local function parseInput()

    local parse = jsonc.new()
    local done, err

    while true do
        local chunk = io.read(4096)
        if not chunk then
            break
        elseif not done and not err then
            done, err = parse:parse(chunk)
        end
    end

    if not done then
        print(jsonc.stringify({
            error = err or "Incomplete input for argument parsing"
        }))
        os.exit(1)
    end

    return parse:get()
end

-- validation
local function validateArgs(func, uargs)

    local method = methods[func]
    if not method then
        print(jsonc.stringify({error = "Method not found in methods table"}))
        os.exit(1)
    end

    local n = 0
    for _, _ in pairs(uargs) do n = n + 1 end

    if method.args and n == 0 then
        print(jsonc.stringify({
            error = "Received empty arguments for " .. func ..
                " but it requires " .. jsonc.stringify(method.args)
        }))
        os.exit(1)
    end

    uargs.ubus_rpc_session = nil

    local margs = method.args or {}
    for k, v in pairs(uargs) do
        if margs[k] == nil or (v ~= nil and type(v) ~= type(margs[k])) then
            print(jsonc.stringify({
                error = "Invalid argument '" .. k .. "' for " .. func ..
                    " it requires " .. jsonc.stringify(method.args)
            }))
            os.exit(1)
        end
    end

    return method
end

-- ubus list & call
if arg[1] == "list" then
    local _, rv = nil, {}
    for _, method in pairs(methods) do rv[_] = method.args or {} end
    print((jsonc.stringify(rv):gsub(":%[%]", ":{}")))
elseif arg[1] == "call" then
    local args = parseInput()
    local method = validateArgs(arg[2], args)
    local run = method.call(args)
    print(run.result)
    os.exit(run.code or 0)
end
