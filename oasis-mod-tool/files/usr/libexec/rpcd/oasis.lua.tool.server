#!/usr/bin/env lua

--[[

# Oasis Local Tool (OLT) Server (Lua Script Ver)
 This server script is based on concepts inspired by the Model Context Protocol and Agents.json.
 By leveraging UBUS, an integral part of the OpenWrt ecosystem, the client and server can cooperate
 to allow the AI to access the tools it provides.
 On OpenWrt systems with Oasis and oasis-mod-tool installed, third-party developers can easily expose
 tools to the AI by simply downloading server scripts.

# Rules for defining tools in the local tool server
    - Rule 1. 
        If a tool requires arguments, you must specify a type string for each argument.

        Reference:
        1. string type  ---> "a_string"
        TODO: Investigate data type specifications other than "a_string" and add them here. 

    - Rule 2. 
        The table returned by server.response must be an associative array (key-value pairs).

        Example: 
        server.response({reply = "Hello Tool Client!"})

# Note
 This script is loaded by the `rpcd` module and registered with `ubusd` as a UBUS object.  

# Important
 Please avoid defining global functions in ubus server scripts.
 For AI tool scripts used in Oasis (like this one), write your logic using server.tool.
 If you need to create custom functions, put them inside the call field of the table that’s passed as the second argument to server.tool.
 The same rule applies when using require to load external libraries—make sure to call require inside the call field too.

 About rpcd lua plugin:
 https://github.com/openwrt/luci/blob/37ea60da580490a4d8178134297152661f25151d/applications/luci-app-example/root/usr/libexec/rpcd/luci.example
]]

local server = require("oasis.local.tool.server")

server.tool("get_ifname_list", {
    tool_desc = "Get the list of all network interface names on this OpenWrt device.",
    call = function()
        local res_tbl = {}
        local index = 1

        -- Get all network interface names from /sys/class/net.
        local handle = io.popen("ls /sys/class/net")
        if handle then
            for line in handle:lines() do
                local key = "ifname" .. index
                res_tbl[key] = line
                index = index + 1
            end
            handle:close()
        end

        return server.response(res_tbl)
    end
})

server.tool("get_lan_ipaddr", {
    tool_desc = "Get the LAN IP Address of this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local ip = util.trim(util.exec("uci get network.lan.ipaddr 2>/dev/null"))
        local res = server.response({lan_ipaddr = ip ~= "" and ip or nil})
        return res
    end
})

server.tool("get_wan_status", {
    tool_desc = "Get the WAN Status of this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local json = util.exec("ubus call network.interface.wan status 2>/dev/null")
        local wan_status = require("luci.jsonc").parse(json)
        local res = server.response({
            up = wan_status and wan_status.up or false,
            ipv4_address = wan_status and wan_status['ipv4-address'] and wan_status['ipv4-address'][1] and wan_status['ipv4-address'][1].address or nil
        })
        return res
    end
})

server.tool("get_connected_clients", {
    tool_desc = "Get connected clients (STAs) on this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local jsonc = require("luci.jsonc")
        local leases = {}

        local function add_lease(ip, mac, hostname)
            if not ip or ip == "" then return end
            for _, l in ipairs(leases) do
                if l.ip == ip then
                    -- update missing fields if available
                    if (not l.mac or l.mac == "") and mac and mac ~= "" then l.mac = mac end
                    if (not l.hostname or l.hostname == "") and hostname and hostname ~= "" then l.hostname = hostname end
                    return
                end
            end
            local e = { ip = ip }
            if mac and mac ~= "" then e.mac = mac end
            if hostname and hostname ~= "" then e.hostname = hostname end
            table.insert(leases, e)
        end

        local function extract_from_record(rec)
            if not rec then return nil, nil, nil end
            local ip = rec.ip
            -- IPv6 leases often carry addresses under 'ipv6-addr' array
            if not ip and rec["ipv6-addr"] and type(rec["ipv6-addr"]) == "table" and rec["ipv6-addr"][1] then
                ip = rec["ipv6-addr"][1].address
            end
            if not ip and rec["ipv6-address"] and type(rec["ipv6-address"]) == "table" and rec["ipv6-address"][1] then
                ip = rec["ipv6-address"][1].address
            end
            local mac = rec.mac or rec.macaddr or rec.hwaddr or rec.duid
            local hostname = rec.hostname
            return ip, mac, hostname
        end

        local function parse_and_add(obj)
            if not obj then return end
            -- direct leases array
            if obj.leases and type(obj.leases) == "table" then
                for _, rec in ipairs(obj.leases) do
                    local ip, mac, hostname = extract_from_record(rec)
                    add_lease(ip, mac, hostname)
                end
            end
            -- device -> iface -> leases
            if obj.device and type(obj.device) == "table" then
                for _, dev in pairs(obj.device) do
                    if dev and dev.leases and type(dev.leases) == "table" then
                        for _, rec in ipairs(dev.leases) do
                            local ip, mac, hostname = extract_from_record(rec)
                            add_lease(ip, mac, hostname)
                        end
                    end
                end
            end
        end

        -- IPv4 STAs info
        do
            local ipv4_stas = util.exec("ubus call dhcp ipv4leases 2>/dev/null")
            local parsed = jsonc.parse(ipv4_stas)
            parse_and_add(parsed)
        end

        -- IPv6 STAs info
        do
            local ipv6_stas = util.exec("ubus call dhcp ipv6leases 2>/dev/null")
            local parsed = jsonc.parse(ipv6_stas)
            parse_and_add(parsed)
        end

        -- ARP table fallback
        local arp = util.exec("cat /proc/net/arp 2>/dev/null") or ""
        for line in arp:gmatch("[^\r\n]+") do
            if not line:match("IP address") then
                -- typical /proc/net/arp: IP address HW type Flags HW address Mask Device
                local ip, hwaddr = line:match("^(%S+)%s+%S+%s+%S+%s+(%S+)")
                if ip and hwaddr and hwaddr ~= "00:00:00:00:00:00" then
                    add_lease(ip, hwaddr, nil)
                end
            end
        end

        return server.response({clients = leases})
    end
})

server.tool("get_system_load", {
    tool_desc = "Get the system info load (uptime/meminfo) of this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local uptime_info = util.exec("uptime")
        local meminfo = util.exec("cat /proc/meminfo")
        local mem_total = meminfo:match("MemTotal:%s+(%d+)")
        local mem_free = meminfo:match("MemFree:%s+(%d+)")
        local res =  server.response({
            uptime = util.trim(uptime_info),
            mem_total_kb = tonumber(mem_total),
            mem_free_kb = tonumber(mem_free)
        })
        return res
    end
})

server.tool("get_storage_usage", {
    tool_desc = "Get the storage usage of this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local df = util.exec("df -h / 2>/dev/null | tail -n 1")
        local size, used, avail, usep = df:match("%S+%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)")
        local res = server.response({
            size = size,
            used = used,
            available = avail,
            usage_percent = usep
        })
        return res
    end
})

server.tool("get_cpu_temp", {
    tool_desc = "Get the CPU temperature of this OpenWrt device.",
    call = function()
        local util = require("luci.util")
        local temp = util.exec("cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null")
        local temp_c = tonumber(temp) and tonumber(temp) / 1000 or nil
        local res = server.response({cpu_temp_c = temp_c})
        return res
    end
})

server.run(arg)